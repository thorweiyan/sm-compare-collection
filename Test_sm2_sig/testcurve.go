package main

import (
	"math/big"
	"fmt"
)

func main(){
	var SM2_Sig_PriKey = []uint8{0x12, 0x8B, 0x2F, 0xA8, 0xBD, 0x43, 0x3C, 0x6C, 0x06, 0x8C, 0x8D, 0x80, 0x3D, 0xFF, 0x79, 0x79, 0x2A, 0x51, 0x9A, 0x55, 0x17, 0x1B, 0x1B, 0x65, 0x0C, 0x23, 0x66, 0x1D, 0x15, 0x89, 0x72, 0x63}
	var K = []uint8{0x6C,0xB2,0x8D,0x99,0x38,0x5C,0x17,0x5C,0x94,0xF9,0x4E,0x93,0x48,0x17,0x66,0x3F,0xC1,0x76,0xD9,0x25,0xDD,0x72,0xB7,0x27,0x26,0x0D,0xBA,0xAE,0x1F,0xB2,0xF9,0x6F}
	var R = []uint8{0x40,0xF1,0xEC,0x59,0xF7,0x93,0xD9,0xF4,0x9E,0x09,0xDC,0xEF,0x49,0x13,0x0D,0x41,0x94,0xF7,0x9F,0xB1,0xEE,0xD2,0xCA,0xA5,0x5B,0xAC,0xDB,0x49,0xC4,0xE7,0x55,0xD1}
	var N = []uint8{0x85,0x42,0xD6,0x9E,0x4C,0x04,0x4F,0x18,0xE8,0xB9,0x24,0x35,0xBF,0x6F,0xF7,0xDD,0x29,0x77,0x20,0x63,0x04,0x85,0x62,0x8D,0x5A,0xE7,0x4E,0xE7,0xC3,0x2E,0x79,0xB7}
	var Z1 = []uint8{0x79,0xBF,0xCF,0x30,0x52,0xC8,0x0D,0xA7,0xB9,0x39,0xE0,0xC6,0x91,0x4A,0x18,0xCB,0xB2,0xD9,0x6D,0x85,0x55,0x25,0x6E,0x83,0x12,0x27,0x43,0xA7,0xD4,0xF5,0xF9,0x56}
	dA:=big.NewInt(0)
	k:=big.NewInt(0)
	z1:=big.NewInt(0)
	_z1:=big.NewInt(0)
	z2:=big.NewInt(0)
	r:=big.NewInt(0)
	s:=big.NewInt(0)
	n:=big.NewInt(0)
	tmp:=big.NewInt(0)

	dA.SetBytes(SM2_Sig_PriKey)
	k.SetBytes(K)
	r.SetBytes(R)
	n.SetBytes(N)

	z1.Add(dA,big.NewInt(1))
	tmp.ModInverse(z1,n)
	z1 = tmp
	//z1.Sub(n,z1)
	//z1.GCD(nil,nil,z1,n)
	//z1.Exp(z1,big.NewInt(-1),n)
	_z1.SetBytes(Z1)
	z2.Mul(r,dA)
	z2.Mod(z2,n)
	z2.Sub(k,z2)
	z2.Add(z2,n)
	s.Mul(z2,z1)
	s.Mod(s,n)
	fmt.Printf("z1:%x\n",z1.Bytes())
	fmt.Printf("s:%x\n",s.Bytes())
	fmt.Printf("r:%x\n",r.Bytes())
	fmt.Printf("n:%x\n",n.Bytes())
}
